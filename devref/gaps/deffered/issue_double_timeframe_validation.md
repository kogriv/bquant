# Технический долг: Ошибка двойной валидации таймфрейма

**Дата обнаружения:** 2025-08-31

## 1. Описание проблемы

При использовании функции `bquant.data.loader.load_symbol_data` с источником, который требует маппинга таймфрейма (например, `data_source='metatrader'`), возникает ошибка `Unsupported timeframe`.

**Сценарий воспроизведения:**
```python
# Этот код вызывает ошибку
load_symbol_data("XAUUSD", "1h", data_source='metatrader')
```

## 2. Симптом (сообщение об ошибке)

В лог выводится следующее сообщение:
```
❌ Loading with load_symbol_data helper failed: Unsupported timeframe: H1. Supported: ['1m', '2m', ...]
```

## 3. Анализ корневой причины

Ошибка возникает из-за избыточной валидации таймфрейма в цепочке вызовов:

1.  `load_symbol_data` получает универсальный таймфрейм **`"1h"`**. Она корректно валидирует его по списку `SUPPORTED_TIMEFRAMES`.
2.  Затем `load_symbol_data` преобразует (маппит) `"1h"` в специфичный для MetaTrader таймфрейм **`"H1"`**.
3.  После этого она вызывает внутреннюю функцию `get_data_path`, передавая ей уже преобразованное значение `"H1"`.
4.  Функция `get_data_path` в целях безопасности **повторно** вызывает `validate_timeframe` для полученного значения `"H1"`.
5.  Проверка `validate_timeframe("H1")` проваливается, так как в словаре `SUPPORTED_TIMEFRAMES` содержатся только универсальные обозначения (`1h`, `4h` и т.д.), но не `H1`.

Таким образом, проблема не в логике маппинга, а в повторной проверке уже преобразованного значения.

## 4. Принятое временное решение

В качестве немедленного исправления в файле `bquant/core/config.py` была закомментирована строка валидации внутри функции `get_data_path`.

```python
# в функции get_data_path
# timeframe = validate_timeframe(timeframe) # <-- Эта строка закомментирована
```

Это решает проблему, но делает функцию `get_data_path` менее безопасной при прямом вызове с непроверенными данными.

## 5. Варианты постоянного решения (на будущее)

### Вариант А: Убрать валидацию (текущее решение)

*   **Логика:** Оставить ответственность за валидацию только на функциях верхнего уровня (`load_symbol_data`), которые работают напрямую с пользовательским вводом. `get_data_path` остается простой "строителем" пути.
*   **Плюсы:** Простота, устранение дублирования кода.
*   **Минусы:** Снижение "самодостаточности" и безопасности функции `get_data_path`.

### Вариант Б (Рекомендуется): Добавить флаг для пропуска валидации

*   **Логика:** Явно указать, когда валидацию нужно пропустить. Это сохранит безопасность `get_data_path` для внешних вызовов.
*   **Реализация:**
    1.  Изменить сигнатуру `get_data_path` на `get_data_path(..., _skip_validation: bool = False)`.
    2.  Обернуть вызов валидации в условие: `if not _skip_validation: ...`
    3.  Из `load_symbol_data` вызывать `get_data_path` с флагом `_skip_validation=True`.
*   **Плюсы:** Надежно, сохраняет безопасность, код явно выражает намерение.
*   **Минусы:** Незначительное усложнение сигнатуры функции.
