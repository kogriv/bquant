# Режимы отображения временной оси в графиках

Этот документ описывает проблему разрывов на финансовых графиках и два подхода к ее решению, реализованных в системе визуализации BQuant.

## 1. Проблема: Разрывы на временной оси

При построении финансовых графиков (например, свечных) с использованием временной оси (`DatetimeIndex`), библиотеки, такие как Plotly, по умолчанию создают непрерывную шкалу времени. Это приводит к появлению "дыр" или пустых мест на графике, соответствующих неторговым периодам (выходные, праздники).

**Пример:**

![Пример графика с разрывами](https://i.imgur.com/gJ84s62.png)  
*График XAU/USD (1 час) с видимыми разрывами на выходных.*

**Недостатки такого отображения:**
- **Визуальные искажения:** Длинные тренды могут выглядеть прерванными.
- **Неэффективное использование пространства:** Значительная часть графика занята пустым местом.

## 2. Текущее решение: Режим "Плотного" графика (`dense`)

Для решения этой проблемы в `bquant/visualization/zones.py` был реализован механизм "плотного" отображения.

**Как это работает:**
1.  **Замена индекса:** Вместо `DatetimeIndex` для оси X используется простой порядковый индекс (`[0, 1, 2, ..., n-1]`). Это гарантирует, что все свечи отображаются вплотную друг к другу.
2.  **"Умные" метки:** Оригинальные временные метки (`DatetimeIndex`) используются для создания кастомных подписей на оси X. Специальная логика форматирует их в два этажа (например, `ДД.ММ` сверху, `ЧЧ:ММ` снизу) и динамически регулирует их количество для оптимальной читаемости.

```python
# Концепция текущей реализации
x_positions = list(range(len(price_data)))
x_dates = price_data.index

fig.add_trace(go.Candlestick(
    x=x_positions, # Используем порядковый индекс
    ...
))

# ... логика создания "умных" меток ...

fig.update_xaxes(
    tickmode='array',
    tickvals=tick_positions, # Позиции для меток
    ticktext=tick_labels    # Текст меток (даты/время)
)
```

**Преимущества:**
- Гарантированно плотный график без разрывов.
- Полный контроль над форматированием меток оси X.

**Недостатки:**
- **Потеря временной пропорциональности:** Ось X перестает быть настоящей временной шкалой. Визуальное расстояние между двумя свечами всегда одинаково, неважно, прошел ли между ними 1 час или 2 дня. Это может вводить в заблуждение при анализе скорости и длительности трендов.

## 3. Реализованное улучшение: Режим `timeseries` с `rangebreaks`

✅ **Реализовано** (2025-11-04): Реализован второй, опциональный режим отображения, основанный на реальной временной шкале с автоматическим скрытием неторговых периодов.

**Как это работает:**
1.  **Сохранение `DatetimeIndex`:** График строится напрямую на оригинальном `DatetimeIndex`.
2.  **Динамический анализ разрывов:** Перед построением графика запускается функция, которая анализирует весь временной ряд, находит все периоды, где разница между свечами превышает нормальный интервал (например, > 2 часов для часового графика), и формирует из них "маску" — список точных интервалов для скрытия.
3.  **Применение `rangebreaks`:** Сгенерированная "маска" передается в параметр `rangebreaks` оси X. Plotly "вырезает" эти периоды, создавая плотный график, но сохраняя при этом временную целостность.

```python
# Фактическая реализация (bquant/visualization/zones.py)

# 1. Анализ разрывов
gap_mask = find_all_gaps(price_data.index)  # Возвращает list[list[str]] - список пар [start, end] в ISO формате

# 2. Построение графика на реальном DatetimeIndex
fig.add_trace(go.Candlestick(
    x=price_data.index, # Используем реальный временной индекс
    open=price_data['open'],
    high=price_data['high'],
    low=price_data['low'],
    close=price_data['close'],
    ...
))

# 3. Добавление зон с использованием DatetimeIndex
for zone in zones:
    fig.add_vrect(
        x0=zone['start_time'],  # Даты, а не позиции
        x1=zone['end_time'],
        ...
    )

# 4. Добавление индикаторов (если есть)
if show_indicators and indicator_columns:
    for column in indicator_columns:
        # Индикаторы также используют DatetimeIndex
        fig.add_trace(go.Bar(x=price_data.index, y=price_data[column], ...), row=2, col=1)

# 5. Скрытие разрывов через rangebreaks
# Важно: каждый разрыв должен быть отдельным dict с bounds
if gap_mask:
    rangebreaks = [dict(bounds=gap) for gap in gap_mask]
    fig.update_xaxes(
        type='date',  # Явно указываем тип оси
        rangebreaks=rangebreaks,
        row=1, col=1
    )
```

**Преимущества:**
- **Аналитическая точность:** График остается пропорциональным времени. Визуальная длина тренда точно соответствует его реальной длительности.
- **Простота меток:** Не требуется сложная логика "умных" меток, так как Plotly отлично справляется с форматированием нативной временной оси.

## 4. Реализованный выбор режима

✅ **Реализовано** (2025-11-04): Пользователь может выбирать между двумя режимами через параметр `time_axis_mode`:
- `'dense'` (по умолчанию) - для быстрого обзора с плотным графиком
- `'timeseries'` - для глубокого анализа с сохранением временной пропорциональности

**Реализация:**

```python
# Фактическая реализация в bquant/visualization/zones.py

def _create_plotly_zones_on_price(self, price_data: pd.DataFrame,
                                 zones: List[Dict], title: str,
                                 time_axis_mode: str = 'dense',  # ← Параметр выбора режима
                                 show_indicators: bool = False,
                                 indicator_columns: Optional[List[str]] = None,
                                 **kwargs) -> go.Figure:
    ...
    if time_axis_mode == 'timeseries':
        # Режим timeseries: DatetimeIndex + rangebreaks
        gap_mask = find_all_gaps(price_data.index)
        # ... построение графика на DatetimeIndex ...
    else:  # time_axis_mode == 'dense' (по умолчанию)
        # Режим dense: порядковый индекс + умные метки
        x_positions = list(range(len(price_data)))
        # ... построение графика на порядковом индексе ...
    ...
```

**Использование:**

```python
# Через ZoneAnalysisResult.visualize()
result.visualize(
    "overview",
    date_range=(start_date, end_date),
    time_axis_mode='timeseries',  # или 'dense'
    show_indicators=True
)
```

BQuant теперь предлагает два режима визуализации, закрывая потребности как в наглядности, так и в аналитической строгости.

## 5. Подкапотная реализация режима `timeseries`

Чтобы лучше понять, как будет работать режим `timeseries`, рассмотрим детальный псевдокод ключевых компонентов.

### 5.1. Функция поиска разрывов `find_all_gaps`

✅ **Реализовано** (2025-11-04): Функция размещена в `bquant/visualization/utils.py`.

**Реализация:**

```python
# Фактическая реализация в bquant/visualization/utils.py
import pandas as pd

def find_all_gaps(dt_index: pd.DatetimeIndex) -> list[list[str]]:
    """
    Анализирует DatetimeIndex, находит разрывы и возвращает их в формате,
    совместимом с Plotly rangebreaks.
    
    Returns:
        list[list[str]]: Список пар [start, end] в формате ISO строк,
                        например: [["2025-06-27T23:00:00", "2025-06-30T00:00:00"]]
    """
    if not isinstance(dt_index, pd.DatetimeIndex) or len(dt_index) < 2:
        return []

    # 1. Вычисляем разницу во времени между соседними точками
    time_diffs = dt_index.to_series().diff()

    # 2. Определяем нормальный интервал (медиана - для устойчивости к выбросам)
    #    и порог для определения "разрыва" (в 1.5 раза больше нормы)
    normal_interval = time_diffs.median()
    gap_threshold = normal_interval * 1.5

    # 3. Находим все точки, где начинается разрыв
    gaps = time_diffs[time_diffs > gap_threshold]

    if gaps.empty:
        return []

    # 4. Формируем список интервалов для Plotly
    #    Plotly rangebreaks требует список пар [start, end] в формате ISO строк
    rangebreak_values = []
    for gap_end_time, duration in gaps.items():
        gap_start_time = gap_end_time - duration
        
        # Конвертируем Timestamp в строки ISO для Plotly
        start_str = gap_start_time.isoformat() if hasattr(gap_start_time, 'isoformat') else str(gap_start_time)
        end_str = gap_end_time.isoformat() if hasattr(gap_end_time, 'isoformat') else str(gap_end_time)
        
        # Добавляем интервал в формате, который понимает Plotly
        rangebreak_values.append([start_str, end_str])

    return rangebreak_values
```

**Особенности реализации:**
- Использует медиану для определения нормального интервала (устойчивость к выбросам)
- Порог разрыва: 1.5 × нормальный интервал
- Конвертирует Timestamp в ISO строки через `.isoformat()`
- Возвращает список пар `[start, end]` для использования в `rangebreaks`

### 5.2. Реализованная логика в `_create_plotly_zones_on_price`

✅ **Реализовано** (2025-11-04): Основная функция отрисовки содержит четкое разделение логики для обоих режимов.

**Ключевые особенности реализации:**

1. **Режим `timeseries`:**
   - Использует реальный `DatetimeIndex` для всех traces (свечи, зоны, индикаторы)
   - Зоны добавляются через `fig.add_vrect()` с датами напрямую
   - Индикаторы поддерживаются в отдельной панели (row=2)
   - `rangebreaks` применяется в формате: `[dict(bounds=[start, end]) for gap in gap_mask]`
   - Явно указывается `type='date'` для оси X
   - Нативные метки Plotly (автоматическое форматирование)

2. **Режим `dense` (по умолчанию):**
   - Использует порядковый индекс `[0, 1, 2, ..., n-1]` для всех traces
   - Зоны добавляются через `fig.add_shape()` с позициями
   - Индикаторы также используют позиционные индексы
   - Кастомные "умные" метки с двухэтажным форматом
   - Горизонтальные метки без наклона
   - Умное определение количества меток (8-20, оптимально 12-16)

**Поддержка индикаторов:**

Оба режима поддерживают отображение индикаторов в отдельной панели:
- Автоматическое определение индикаторов из `zone.indicator_context`
- Поддержка типов отображения: `'line'` (по умолчанию) или `'bar'` (для гистограмм)
- Автоматическое определение типа для колонок с `'hist'` в названии
- Возможность явного указания через `indicator_chart_types` dict

**Структура кода:**

```python
# Упрощенная структура фактической реализации
def _create_plotly_zones_on_price(self, price_data: pd.DataFrame,
                                 zones: List[Dict], title: str,
                                 time_axis_mode: str = 'dense',
                                 show_indicators: bool = False,
                                 ...) -> go.Figure:
    
    # Определение количества панелей (1 или 2)
    rows = 2 if show_indicators else 1
    fig = make_subplots(rows=rows, cols=1, shared_xaxes=True, ...)
    
    if time_axis_mode == 'timeseries':
        # Режим timeseries
        gap_mask = find_all_gaps(price_data.index)
        # ... построение на DatetimeIndex ...
        if gap_mask:
            rangebreaks = [dict(bounds=gap) for gap in gap_mask]
            fig.update_xaxes(type='date', rangebreaks=rangebreaks, ...)
        else:
            fig.update_xaxes(type='date', ...)
    else:
        # Режим dense
        x_positions = list(range(len(price_data)))
        # ... построение на порядковом индексе ...
        # ... создание умных меток ...
        fig.update_xaxes(tickmode='array', tickvals=..., ticktext=..., ...)
    
    return fig
```

Эта структура четко разделяет два подхода, повторно используя общие части (например, создание subplots, добавление индикаторов) и изолируя специфичную для каждого режима логику работы с осями.

## 6. Взаимодействие с системой "умных" меток

✅ **Реализовано** (2025-11-04): Система "умных" меток работает только в режиме `dense`, в режиме `timeseries` используется нативное форматирование Plotly.

**В режиме `dense`:**
- Система "умных" меток **является ключевой и незаменимой**
- Поскольку ось X является числовой (порядковый индекс), эта логика превращает числа `0, 1, 2...` в информативные подписи дат и времени
- Двухэтажный формат: дата сверху, время снизу
- Горизонтальные метки без наклона для читаемости
- Умное определение количества меток (8-20, оптимально 12-16)
- Для больших диапазонов (>1 месяца): год показывается отдельно на первом этаже в начале графика и при смене года

**В режиме `timeseries`:**
- Система "умных" меток **не используется и не нужна**
- Plotly автоматически использует встроенные механизмы форматирования временной оси
- Адаптивность к масштабу: при приближении метки автоматически меняют формат и количество
- Оптимальное размещение: алгоритмы Plotly расставляют метки без перекрытий

**Вывод:** Кастомная система "умных" меток — это решение для числовой оси в режиме `dense`. В режиме `timeseries` используется нативное форматирование Plotly, что упрощает код и обеспечивает высокую интерактивность графика.
